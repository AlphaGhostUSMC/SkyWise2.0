const searchInput = document.querySelector("#location-search-input");

const searchForm = document.querySelector(".get-weather");
searchForm.addEventListener("submit", (event) => {
  event.preventDefault();
  const date = new Date();
  date.setTime(date.getTime() + 3600 * 10000);
  const expires = "expires=" + date.toUTCString();
  document.cookie = "searchInput" + "=" + searchInput.value + ";" + expires + ";path=/";
  getCoordinates();
});

// Read the cookie when the page is loaded
const cookieValue = document.cookie
  .split('; ')
  .find(row => row.startsWith('searchInput='))
  .split('=')[1];
if (cookieValue) {
  searchInput.value = cookieValue;
  getCoordinates();
}

async function getCoordinates() {
  try {
    const url = `${endpointCoordinates}?q=${searchInput.value}&limit=1&appid=${apiKey}`;
    const response = await fetch(url);
    const data = await response.json();
    getLongLati(data);
  } catch (error) {
    console.error(error);
  }
}

function getLongLati(data) {
  const longitude = data[0].lon;
  const latitude = data[0].lat;
  getWeatherData(longitude, latitude);
  getForecastData(longitude, latitude);
  getSunriseSunset(longitude, latitude);
}

async function getWeatherData(longitude, latitude) {
  try {
    const url = `${endpointWeather}?lat=${latitude}&lon=${longitude}&appid=${apiKey}&units=metric`;
    const response = await fetch(url);
    const data = await response.json();
    displayWeather(data);
  } catch (error) {
    console.error(error);
  }
}

// Add a function to retrieve the user's favorite location
async function getUserFavoriteLocation() {
  try {
    const response = await fetch('/api/user/favorite-location', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    const result = await response.json();

    if (response.ok) {
      // Retrieve the user's favorite location from the result
      const favoriteLocation = result.favoriteLocation;
      searchInput.value = favoriteLocation;
      getCoordinates();
    } else {
      console.error(result.message);
    }
  } catch (error) {
    console.error(error);
  }
}

async function getForecastData(longitude, latitude) {
  try {
    const url = `${endpointForecast}?lat=${latitude}&lon=${longitude}&appid=${apiKey}&units=metric`;
    const response = await fetch(url);
    const data = await response.json();
    displayForecast(data);
    nextDayIndex(data);
  } catch (error) {
    console.error(error);
  }
}

function getNext5Days() {
  let currentDate = new Date();
  let next5Days = [];

  for (let i = 1; i <= 4; i++) {
    let nextDate = new Date(currentDate);
    nextDate.setDate(currentDate.getDate() + i);
    let formattedDate = nextDate.toISOString().split('T')[0];
    next5Days.push(formattedDate);
  }

  return next5Days;
}

async function getSunriseSunset(longitude, latitude) {
  try {
    const sunriseSunsetDays = getNext5Days();
    for (let i = 0; i < 4; i++) {
      const url = `${endpointSunsetSunrise}lat=${latitude}&lng=${longitude}&date=${sunriseSunsetDays[i]}`;
      const response = await fetch(url);
      const data = await response.json();
      displaySunriseSunset(data, i);
    }
  } catch (error) {
    console.error(error);
  }
}

function displayWeather(data) {

  // Main Weather card Section
  const { name, main, weather } = data;
  const cityMain = document.querySelector(".city-name-main");
  const tempMain = document.querySelector(".temp-main");
  const descriptionMain = document.querySelector(".temp-description");
  const currentWeatherIcon = document.querySelector(".weather-icon-main");
  const weatherDescription = weather[0].description;

  cityMain.textContent = name + ", " + data.sys.country;
  tempMain.textContent = main.temp + " ℃";
  descriptionMain.textContent = weather[0].description;
  currentWeatherIcon.src = weatherIcon[weatherDescription];

  // Humidity, Pressure and Visibility
  const humidityMain = document.querySelector(".humidity-main");
  const visibilityMain = document.querySelector(".visibility-distance-text");
  const atmPressureMain = document.querySelector(".atm-pressure-text");

  humidityMain.textContent = main.humidity + "%";
  visibilityMain.textContent = data.visibility / 1000 + " km";
  atmPressureMain.textContent = main.pressure + " hPa";

  // Wind Speed, Direction and Gust
  const windSpeed = document.querySelector(".wind-main");
  const windDirection = document.querySelector(".wind-direction-degree-text");
  const windGustSpeed = document.querySelector(".gust-speed-text");

  windSpeed.textContent = data.wind.speed + " m/s";
  windDirection.textContent = data.wind.deg + "°";
  windGustSpeed.textContent = data.wind.gust + " m/s";

  function wind_direction(deg) {
    const dirs = [
      "N",
      "NNE",
      "NE",
      "ENE",
      "E",
      "ESE",
      "SE",
      "SSE",
      "S",
      "SSW",
      "SW",
      "WSW",
      "W",
      "WNW",
      "NW",
      "NNW",
    ];
    return dirs[Math.round((deg % 360) / 22.5)];
  }

  const deg = data.wind.deg;
  const direction = wind_direction(deg);
  console.log("Wind direction: " + direction);

  const windDirectionIcon = document.querySelector(".wind-direction-icon");
  windDirectionIcon.src = directionIcon[direction];
}

// Get Weekday Names and Index of next day
function getDate() {
  const today = new Date();
  today.setHours(today.getHours() + 5); // Add 5 hours
  today.setMinutes(today.getMinutes() + 30); // Add 30 minutes
  const date = today.toISOString().split("T")[0];
  return date;
}


console.log(getDate());

function nextDayIndex(data) {
  const date = getDate();
  console.log("Current date is: " + date);
  const { list } = data;
  let listIndex = 0;
  let today = list[listIndex].dt_txt.slice(0, 10);
  console.log("Forecast date is: " + today);
  while (date === today) {
    listIndex++;
    console.log("Index is: " + listIndex);
    if (date !== today) {
      break;
    }
    today = list[listIndex].dt_txt.slice(0, 10);
  }
  console.log("Next day index is: " + listIndex);
  const forecastIndex = listIndex;
  return forecastIndex;
}

function getWeekdayNames() {
  const date = new Date();
  const options = { timeZone: "Asia/Kolkata", weekday: "long" };
  const weekdayNames = [];
  for (let i = 0; i < 5; i++) {
    weekdayNames.push(date.toLocaleDateString("en-US", options));
    date.setDate(date.getDate() + 1);
  }
  return weekdayNames;
}

let weekdayNames = getWeekdayNames();
console.log(weekdayNames);


// Forecast Section



function displayForecast(data) {
  const day1 = document.querySelector(".day1-text");
  const day2 = document.querySelector(".day2-text");
  const day3 = document.querySelector(".day3-text");
  const day4 = document.querySelector(".day4-text");

  day1.textContent = weekdayNames[1];
  day2.textContent = weekdayNames[2];
  day3.textContent = weekdayNames[3];
  day4.textContent = weekdayNames[4];

  const { list } = data;
  let indexVal = nextDayIndex(data);

  const setForecast = (index, day, hour) => {
    const timeSelector = `.forecast-day${day}-hour${hour}`;
    const iconSelector = `.day${day}-hour${hour}-image-main`;
    const tempSelector = `.forecast-day${day}-hour${hour}-temp`;
    const descSelector = `.forecast-day${day}-hour${hour}-desc`;
    const minTempSelector = `.min-temp-${day}${hour}`;
    const maxTempSelector = `.max-temp-${day}${hour}`;

    const forecastTime = document.querySelector(timeSelector);
    const forecastIcon = document.querySelector(iconSelector);
    const description = list[index].weather[0].description;
    const forecastTemp = document.querySelector(tempSelector);
    const forecastDesc = document.querySelector(descSelector);
    const minTemp = document.querySelector(minTempSelector);
    const maxTemp = document.querySelector(maxTempSelector);

    console.log("Forecast Date: " + list[index].dt_txt);
    forecastTime.textContent = list[index].dt_txt.slice(11, 16);
    forecastIcon.src = weatherIcon[description];
    forecastTemp.textContent = list[index].main.temp + " ℃";
    forecastDesc.textContent = list[index].weather[0].description;
    minTemp.textContent = list[index].main.temp_min + " ℃";
    maxTemp.textContent = list[index].main.temp_max + " ℃";
  };

  const setForecasts = (day) => {
    const offset = (day - 1) * 8;

    setForecast(indexVal + offset + 2, day, '1');
    setForecast(indexVal + offset + 3, day, '2');
    setForecast(indexVal + offset + 4, day, '3');
    setForecast(indexVal + offset + 5, day, '4');
    setForecast(indexVal + offset + 6, day, '5');
  };

  setForecasts(1);
  setForecasts(2);
  setForecasts(3);
  setForecasts(4);

}


function displaySunriseSunset(data, index) {
  const sunriseTime = document.querySelector(`.sunrise-text${index + 1}`);
  const sunsetTime = document.querySelector(`.sunset-text${index + 1}`);
  sunriseTime.textContent = data.results.sunrise;
  sunsetTime.textContent = data.results.sunset;
}

// Retrieve the user's favorite location when the page is loaded
getUserFavoriteLocation();


---------------------------------

server.js

require('dotenv').config();
const express = require('express');
const { MongoClient } = require('mongodb');
const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const app = express();
const path = require('path');

// Generate a secret key for JWT signing
const secretKey = crypto.randomBytes(32).toString('hex');
console.log(secretKey);

const muser = process.env.MONGODB_USERNAME;
const mpass = process.env.MONGODB_PASSWORD;
const db = process.env.MONGODB_DATABASE;

// Serve static files from the "public" directory
app.use(express.static(path.join(__dirname, 'public')));

// Middleware to parse JSON request body
app.use(express.json());

// Define a route to serve the index.html file
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'index.html'));
});

app.get('/login.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'login.html'));
});

app.get('/register.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'register.html'));
});

app.get('/app.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'app.html'));
});

// MongoDB connection string
const uri = `mongodb+srv://${muser}:${mpass}@alphadbv1.9q93m.mongodb.net/${db}?retryWrites=true&w=majority`;

// Route for handling the registration form submission
app.post('/register', async (req, res) => {
  const { username, email, location, password } = req.body;

  // Validate the registration details here (same validation logic as in auth.js)
  // ...

  let client; // Declare the client variable outside the try block

  try {
    client = new MongoClient(uri);

    await client.connect();
    console.log('Connected to MongoDB');

    const collection = client.db('SkyWise').collection('users');

    // Check if the username or email already exists in the collection
    const existingUser = await collection.findOne({ $or: [{ username }, { email }] });
    if (existingUser) {
      console.log('User already exists:', existingUser);

      return res.status(409).json({ success: false, message: 'User already exists' });
    }

    // Hash the password before storing it
    const hashedPassword = crypto.createHash('sha256').update(password).digest('hex');

    // Insert the registration details into the collection
    await collection.insertOne({ username, email, location, password: hashedPassword });

    console.log('Registration details stored in MongoDB');

    // Redirect to the login.html page
    res.redirect('/login.html');
  } catch (error) {
    console.log('Error storing registration details:', error);

    res.status(500).json({ success: false, message: 'Registration failed' });
  } finally {
    // Close the MongoDB connection if the client is defined
    if (client) {
      client.close();
      console.log('Disconnected from MongoDB');
    }
  }
});

// Route for handling the login request
app.post('/login', async (req, res) => {
  const { username, password } = req.body;

  let client;

  try {
    client = new MongoClient(uri);

    await client.connect();
    console.log('Connected to MongoDB');

    const collection = client.db('SkyWise').collection('users');

    // Find the user with the provided username
    const user = await collection.findOne({ username });

    if (!user) {
      // User not found
      return res.status(401).json({ success: false, message: 'Invalid Username' });
    }

    // Hash the provided password and compare it with the stored password
    const hashedPassword = crypto.createHash('sha256').update(password).digest('hex');

    if (hashedPassword !== user.password) {
      // Passwords don't match
      return res.status(401).json({ success: false, message: 'Invalid Password' });
    }

    // Generate a JWT token
    const token = jwt.sign({ username: user.username }, secretKey, { expiresIn: '1h' });

    // Login successful, send the token as a response
    res.status(200).json({ success: true, message: 'Login successful', token });
  } catch (error) {
    console.log('Error during login:', error);

    res.status(500).json({ success: false, message: 'Login failed' });
  } finally {
    // Close the MongoDB connection if the client is defined
    if (client) {
      client.close();
      console.log('Disconnected from MongoDB');
    }
  }
});

// Protected route
app.get('/protected', (req, res) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.status(401).json({ success: false, message: 'Authorization token not provided' });
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.status(403).json({ success: false, message: 'Invalid token' });
    }

    const { username } = decoded;

    console.log('Protected route accessed by:', username);
    // Perform any necessary actions for the protected route
    // ...

    res.json({ success: true, message: 'Protected route accessed successfully.' });
  });
});

// Middleware for verifying JWT token
const verifyToken = (req, res, next) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.status(401).json({ success: false, message: 'Authorization token not provided' });
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.status(403).json({ success: false, message: 'Invalid token' });
    }

    req.decoded = decoded;
    next();
  });
};

// Route for fetching the user's favorite location
app.get('/api/user/favorite-location', verifyToken, async (req, res) => {
  // Extract the username from the decoded token
  const { username } = req.decoded;

  let client;

  try {
    client = new MongoClient(uri);

    await client.connect();
    console.log('Connected to MongoDB');

    const collection = client.db('SkyWise').collection('users');

    // Find the user with the provided username
    const user = await collection.findOne({ username });

    if (!user) {
      // User not found
      return res.status(404).json({ success: false, message: 'User not found' });
    }

    // Send the favorite location as a response
    res.status(200).json({ success: true, favoriteLocation: user.location });
  } catch (error) {
    console.log('Error fetching favorite location:', error);

    res.status(500).json({ success: false, message: 'Server error' });
  } finally {
    // Close the MongoDB connection if the client is defined
    if (client) {
      client.close();
      console.log('Disconnected from MongoDB');
    }
  }
});

// Start the server
const port = 5050; // Change this to the desired port number
app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
  console.log(`http://localhost:${port}`);
});

_____________

require('dotenv').config();
const express = require('express');
const { MongoClient } = require('mongodb');
const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const app = express();
const path = require('path');

// Generate a secret key for JWT signing
const secretKey = crypto.randomBytes(32).toString('hex');
console.log(secretKey);

const muser = process.env.MONGODB_USERNAME;
const mpass = process.env.MONGODB_PASSWORD;
const db = process.env.MONGODB_DATABASE;

// Serve static files from the "public" directory
app.use(express.static(path.join(__dirname, 'public')));

// Middleware to parse JSON request body
app.use(express.json());

// Define a route to serve the index.html file
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'index.html'));
});

app.get('/login.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'login.html'));
});

app.get('/register.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'register.html'));
});

// MongoDB connection string
const uri = `mongodb+srv://${muser}:${mpass}@alphadbv1.9q93m.mongodb.net/${db}?retryWrites=true&w=majority`;

// Route for handling the registration form submission
app.post('/register', async (req, res) => {
  const { username, email, location, password } = req.body;

  // Validate the registration details here (same validation logic as in auth.js)
  // ...

  let client; // Declare the client variable outside the try block

  try {
    client = new MongoClient(uri);

    await client.connect();
    console.log('Connected to MongoDB');

    const collection = client.db('SkyWise').collection('users');

    // Check if the username or email already exists in the collection
    const existingUser = await collection.findOne({ $or: [{ username }, { email }] });
    if (existingUser) {
      console.log('User already exists:', existingUser);

      return res.status(409).json({ success: false, message: 'User already exists' });
    }

    // Hash the password before storing it
    const hashedPassword = crypto.createHash('sha256').update(password).digest('hex');

    // Insert the registration details into the collection
    await collection.insertOne({ username, email, location, password: hashedPassword });

    console.log('Registration details stored in MongoDB');

    // Redirect to the login.html page
    res.redirect('/login.html');
  } catch (error) {
    console.log('Error storing registration details:', error);

    res.status(500).json({ success: false, message: 'Registration failed' });
  } finally {
    // Close the MongoDB connection if the client is defined
    if (client) {
      client.close();
      console.log('Disconnected from MongoDB');
    }
  }
});

// Route for handling the login request
app.post('/login', async (req, res) => {
  const { username, password } = req.body;

  let client;

  try {
    client = new MongoClient(uri);

    await client.connect();
    console.log('Connected to MongoDB');

    const collection = client.db('SkyWise').collection('users');

    // Find the user with the provided username
    const user = await collection.findOne({ username });

    if (!user) {
      // User not found
      return res.status(401).json({ success: false, message: 'Invalid Username' });
    }

    // Hash the provided password and compare it with the stored password
    const hashedPassword = crypto.createHash('sha256').update(password).digest('hex');

    if (hashedPassword !== user.password) {
      // Passwords don't match
      return res.status(401).json({ success: false, message: 'Invalid Password' });
    }

    // Generate a JWT token
    const token = jwt.sign({ username: user.username }, secretKey, { expiresIn: '1h' });

    // Login successful, send the token as a response
    res.status(200).json({ success: true, message: 'Login successful', token });
  } catch (error) {
    console.log('Error during login:', error);

    res.status(500).json({ success: false, message: 'Login failed' });
  } finally {
    // Close the MongoDB connection if the client is defined
    if (client) {
      client.close();
      console.log('Disconnected from MongoDB');
    }
  }
});

// Protected route
app.get('/protected', (req, res) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.status(401).json({ success: false, message: 'Authorization token not provided' });
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.status(403).json({ success: false, message: 'Invalid token' });
    }

    const { username } = decoded;

    console.log('Protected route accessed by:', username);
    // Perform any necessary actions for the protected route
    // ...

    res.json({ success: true, message: 'Protected route accessed successfully.' });
  });
});

// Middleware for verifying JWT token
const verifyToken = (req, res, next) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.status(401).json({ success: false, message: 'Authorization token not provided' });
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.status(403).json({ success: false, message: 'Invalid token' });
    }

    req.decoded = decoded;
    next();
  });
};

// Route for fetching the user's favorite location
app.get('/app.html', verifyToken, (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'app.html'));
});

app.get('/api/user/favorite-location', verifyToken, async (req, res) => {
  // Extract the username from the decoded token
  const { username } = req.decoded;

  let client;

  try {
    client = new MongoClient(uri);

    await client.connect();
    console.log('Connected to MongoDB');

    const collection = client.db('SkyWise').collection('users');

    // Find the user with the provided username
    const user = await collection.findOne({ username });

    if (!user) {
      // User not found
      return res.status(404).json({ success: false, message: 'User not found' });
    }

    // Send the favorite location as a response
    res.status(200).json({ success: true, favoriteLocation: user.location });
  } catch (error) {
    console.log('Error fetching favorite location:', error);

    res.status(500).json({ success: false, message: 'Server error' });
  } finally {
    // Close the MongoDB connection if the client is defined
    if (client) {
      client.close();
      console.log('Disconnected from MongoDB');
    }
  }
});

// Redirect to index.html if not logged in
app.get('/app.html', (req, res, next) => {
  const token = req.headers.authorization;

  if (!token) {
    res.redirect('/index.html');
  } else {
    next();
  }
});

// Start the server
const port = 5050; // Change this to the desired port number
app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
  console.log(`http://localhost:${port}`);
});

_____________
// Redirect to index.html if not logged in
app.get('/app.html', (req, res, next) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.redirect('/index.html');
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.redirect('/index.html');
    }

    next();
  });
});

_______________________________

require('dotenv').config();
const express = require('express');
const { MongoClient } = require('mongodb');
const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const app = express();
const path = require('path');

// Generate a secret key for JWT signing
const secretKey = crypto.randomBytes(32).toString('hex');
console.log(secretKey);

const muser = process.env.MONGODB_USERNAME;
const mpass = process.env.MONGODB_PASSWORD;
const db = process.env.MONGODB_DATABASE;

// Serve static files from the "public" directory
app.use(express.static(path.join(__dirname, 'public')));

// Middleware to parse JSON request body
app.use(express.json());

// Define a route to serve the index.html file
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'index.html'));
});

app.get('/login.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'login.html'));
});

app.get('/register.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'register.html'));
});

// MongoDB connection string
const uri = `mongodb+srv://${muser}:${mpass}@alphadbv1.9q93m.mongodb.net/${db}?retryWrites=true&w=majority`;

// Route for handling the registration form submission
app.post('/register', async (req, res) => {
  // ... registration route code ...

});

// Route for handling the login request
app.post('/login', async (req, res) => {
  // ... login route code ...
});

// Protected route
app.get('/protected', (req, res) => {
  // ... protected route code ...
});

// Middleware for verifying JWT token
const verifyToken = (req, res, next) => {
  // ... verifyToken middleware code ...
};

// Route for fetching the user's favorite location
app.get('/api/user/favorite-location', verifyToken, async (req, res) => {
  // ... favorite location route code ...
});

// Redirect to index.html if not logged in
app.get('/app.html', (req, res, next) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.redirect('/index.html');
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.redirect('/index.html');
    }

    next();
  });
});

// Start the server
const port = process.env.SERVER_PORT; // Change this to the desired port number
app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
  console.log(`http://localhost:${port}`);
});

_______________________________

require('dotenv').config();
const express = require('express');
const { MongoClient } = require('mongodb');
const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const app = express();
const path = require('path');

// Generate a secret key for JWT signing
const secretKey = crypto.randomBytes(32).toString('hex');
console.log(secretKey);

const muser = process.env.MONGODB_USERNAME;
const mpass = process.env.MONGODB_PASSWORD;
const db = process.env.MONGODB_DATABASE;

// Serve static files from the "public" directory
app.use(express.static(path.join(__dirname, 'public')));

// Middleware to parse JSON request body
app.use(express.json());

// Define a route to serve the index.html file
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'index.html'));
});

app.get('/login.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'login.html'));
});

app.get('/register.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'register.html'));
});

// MongoDB connection string
const uri = `mongodb+srv://${muser}:${mpass}@alphadbv1.9q93m.mongodb.net/${db}?retryWrites=true&w=majority`;

// Route for handling the registration form submission
app.post('/register', async (req, res) => {
  const { username, email, location, password } = req.body;

  // Validate the registration details here (same validation logic as in auth.js)
  // ...

  let client; // Declare the client variable outside the try block

  try {
    client = new MongoClient(uri);

    await client.connect();
    console.log('Connected to MongoDB');

    const collection = client.db('SkyWise').collection('users');

    // Check if the username or email already exists in the collection
    const existingUser = await collection.findOne({ $or: [{ username }, { email }] });
    if (existingUser) {
      console.log('User already exists:', existingUser);

      return res.status(409).json({ success: false, message: 'User already exists' });
    }

    // Hash the password before storing it
    const hashedPassword = crypto.createHash('sha256').update(password).digest('hex');

    // Insert the registration details into the collection
    await collection.insertOne({ username, email, location, password: hashedPassword });

    console.log('Registration details stored in MongoDB');

    // Redirect to the login.html page
    res.redirect('/login.html');
  } catch (error) {
    console.log('Error storing registration details:', error);

    res.status(500).json({ success: false, message: 'Registration failed' });
  } finally {
    // Close the MongoDB connection if the client is defined
    if (client) {
      client.close();
      console.log('Disconnected from MongoDB');
    }
  }
});

// Route for handling the login request
app.post('/login', async (req, res) => {
  const { username, password } = req.body;

  let client;

  try {
    client = new MongoClient(uri);

    await client.connect();
    console.log('Connected to MongoDB');

    const collection = client.db('SkyWise').collection('users');

    // Find the user with the provided username
    const user = await collection.findOne({ username });

    if (!user) {
      // User not found
      return res.status(401).json({ success: false, message: 'Invalid Username' });
    }

    // Hash the provided password and compare it with the stored password
    const hashedPassword = crypto.createHash('sha256').update(password).digest('hex');

    if (hashedPassword !== user.password) {
      // Passwords don't match
      return res.status(401).json({ success: false, message: 'Invalid Password' });
    }

    // Generate a JWT token
    const token = jwt.sign({ username: user.username }, secretKey, { expiresIn: '1h' });

    // Login successful, send the token as a response
    res.status(200).json({ success: true, message: 'Login successful', token });
  } catch (error) {
    console.log('Error during login:', error);

    res.status(500).json({ success: false, message: 'Login failed' });
  } finally {
    // Close the MongoDB connection if the client is defined
    if (client) {
      client.close();
      console.log('Disconnected from MongoDB');
    }
  }
});

// Protected route
app.get('/protected', (req, res) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.status(401).json({ success: false, message: 'Authorization token not provided' });
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.status(403).json({ success: false, message: 'Invalid token' });
    }

    const { username } = decoded;

    console.log('Protected route accessed by:', username);
    // Perform any necessary actions for the protected route
    // ...

    res.json({ success: true, message: 'Protected route accessed successfully.' });
  });
});

// Middleware for verifying JWT token
const verifyToken = (req, res, next) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.status(401).json({ success: false, message: 'Authorization token not provided' });
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.status(403).json({ success: false, message: 'Invalid token' });
    }

    req.decoded = decoded;
    next();
  });
};

// Route for fetching the user's favorite location
app.get('/api/user/favorite-location', verifyToken, async (req, res) => {
  // Extract the username from the decoded token
  const { username } = req.decoded;

  let client;

  try {
    client = new MongoClient(uri);

    await client.connect();
    console.log('Connected to MongoDB');

    const collection = client.db('SkyWise').collection('users');

    // Find the user with the provided username
    const user = await collection.findOne({ username });

    if (!user) {
      // User not found
      return res.status(404).json({ success: false, message: 'User not found' });
    }

    // Send the favorite location as a response
    res.status(200).json({ success: true, favoriteLocation: user.location });
  } catch (error) {
    console.log('Error fetching favorite location:', error);

    res.status(500).json({ success: false, message: 'Server error' });
  } finally {
    // Close the MongoDB connection if the client is defined
    if (client) {
      client.close();
      console.log('Disconnected from MongoDB');
    }
  }
});

// Redirect to index.html if not logged in
app.get('/app.html', (req, res, next) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.redirect('/index.html');
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.redirect('/index.html');
    }

    next();
  });
});

// Start the server
const port = process.env.SERVER_PORT; // Change this to the desired port number
app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
  console.log(`http://localhost:${port}`);
});


________________________________


// Redirect to index.html if not logged in
app.get('/index.html', (req, res, next) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.redirect('/');
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.redirect('/');
    }

    next();
  });
});

// Redirect to app.html if logged in
app.get('/app.html', (req, res, next) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.redirect('/');
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.redirect('/');
    }

    next();
  });
});


_______________________________

// Redirect to app.html if logged in
app.get('/app.html', (req, res, next) => {
  const token = req.headers.authorization;

  if (token) {
    return res.redirect('/app.html');
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.redirect('/');
    }

    next();
  });
});


_______________________________

// Redirect to app.html if not logged in
app.get('/app.html', (req, res, next) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.redirect('/');
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.redirect('/');
    }

    next();
  });
});

// Redirect to login.html if not logged in
app.get('/login.html', (req, res, next) => {
  const token = req.headers.authorization;

  if (token) {
    return res.redirect('/app.html');
  }

  next();
});


_______________________________

// Redirect to app.html if logged in
app.get('/app.html', (req, res, next) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.redirect('/');
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.redirect('/');
    }

    next();
  });
});

_______________________________

const token = jwt.sign({ username: user.username }, secretKey, { expiresIn: '3h' });



const verifyToken = (req, res, next) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.status(401).json({ success: false, message: 'Authorization token not provided' });
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      if (err.name === 'TokenExpiredError') {
        return res.status(403).json({ success: false, message: 'Token expired' });
      }
      return res.status(403).json({ success: false, message: 'Invalid token' });
    }

    req.decoded = decoded;
    next();
  });
};


_______________________________
const crypto = require('crypto');

// Set the seed value for the pseudo-random number generator
const seedValue = 'myseed';

// Create a hash of the seed value
const seedHash = crypto.createHash('sha256').update(seedValue).digest();

// Create a pseudo-random number generator with the seed hash
const prng = crypto.createHash('sha256').update(seedHash);

// Generate the random bytes with the PRNG
const secretKey = prng.digest('hex');
console.log(secretKey);

_______________________________

require('dotenv').config();
const express = require('express');
const { MongoClient } = require('mongodb');
const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const app = express();
const path = require('path');

// Generate a secret key for JWT signing
// Set the seed value for the pseudo-random number generator
const seedValue = 'myseed';

// Create a hash of the seed value
const seedHash = crypto.createHash('sha256').update(seedValue).digest();

// Create a pseudo-random number generator with the seed hash
const prng = crypto.createHash('sha256').update(seedHash);

// Generate the random bytes with the PRNG
const secretKey = prng.digest('hex');
console.log(secretKey);

const muser = process.env.MONGODB_USERNAME;
const mpass = process.env.MONGODB_PASSWORD;
const db = process.env.MONGODB_DATABASE;

// Serve static files from the "public" directory
app.use(express.static(path.join(__dirname, 'public')));

// Middleware to parse JSON request body
app.use(express.json());

// Define a route to serve the index.html file
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'index.html'));
});

app.get('/login.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'login.html'));
});

app.get('/register.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'register.html'));
});

// MongoDB connection string
const uri = `mongodb+srv://${muser}:${mpass}@alphadbv1.9q93m.mongodb.net/${db}?retryWrites=true&w=majority`;

// Route for handling the registration form submission
app.post('/register', async (req, res) => {
  const { username, email, location, password } = req.body;

  // Validate the registration details here (same validation logic as in auth.js)
  // ...

  let client; // Declare the client variable outside the try block

  try {
    client = new MongoClient(uri);

    await client.connect();
    console.log('Connected to MongoDB');

    const collection = client.db('SkyWise').collection('users');

    // Check if the username or email already exists in the collection
    const existingUser = await collection.findOne({ $or: [{ username }, { email }] });
    if (existingUser) {
      console.log('User already exists:', existingUser);

      return res.status(409).json({ success: false, message: 'User already exists' });
    }

    // Hash the password before storing it
    const hashedPassword = crypto.createHash('sha256').update(password).digest('hex');

    // Insert the registration details into the collection
    await collection.insertOne({ username, email, location, password: hashedPassword });

    console.log('Registration details stored in MongoDB');

    // Redirect to the login.html page
    res.redirect('/login.html');
  } catch (error) {
    console.log('Error storing registration details:', error);

    res.status(500).json({ success: false, message: 'Registration failed' });
  } finally {
    // Close the MongoDB connection if the client is defined
    if (client) {
      client.close();
      console.log('Disconnected from MongoDB');
    }
  }
});

// Route for handling the login request
app.post('/login', async (req, res) => {
  const { username, password } = req.body;

  let client;

  try {
    client = new MongoClient(uri);

    await client.connect();
    console.log('Connected to MongoDB');

    const collection = client.db('SkyWise').collection('users');

    // Find the user with the provided username
    const user = await collection.findOne({ username });

    if (!user) {
      // User not found
      return res.status(401).json({ success: false, message: 'Invalid Username' });
    }

    // Hash the provided password and compare it with the stored password
    const hashedPassword = crypto.createHash('sha256').update(password).digest('hex');

    if (hashedPassword !== user.password) {
      // Passwords don't match
      return res.status(401).json({ success: false, message: 'Invalid Password' });
    }

    // Generate a JWT token
    const token = jwt.sign({ username: user.username }, secretKey, { expiresIn: '3h' });

    // Login successful, send the token as a response
    res.status(200).json({ success: true, message: 'Login successful', token });
  } catch (error) {
    console.log('Error during login:', error);

    res.status(500).json({ success: false, message: 'Login failed' });
  } finally {
    // Close the MongoDB connection if the client is defined
    if (client) {
      client.close();
      console.log('Disconnected from MongoDB');
    }
  }
});

// Protected route
app.get('/protected', (req, res) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.status(401).json({ success: false, message: 'Authorization token not provided' });
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.status(403).json({ success: false, message: 'Invalid token' });
    }

    const { username } = decoded;

    console.log('Protected route accessed by:', username);
    // Perform any necessary actions for the protected route
    // ...

    res.json({ success: true, message: 'Protected route accessed successfully.' });
  });
});

// Middleware for verifying JWT token
const verifyToken = (req, res, next) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.status(401).json({ success: false, message: 'Authorization token not provided' });
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      if (err.name === 'TokenExpiredError') {
        return res.status(403).json({ success: false, message: 'Token expired' });
      }
      return res.status(403).json({ success: false, message: 'Invalid token' });
    }

    req.decoded = decoded;
    next();
  });
};

// Route for fetching the user's favorite location
app.get('/api/user/favorite-location', verifyToken, async (req, res) => {
  // Extract the username from the decoded token
  const { username } = req.decoded;

  let client;

  try {
    client = new MongoClient(uri);

    await client.connect();
    console.log('Connected to MongoDB');

    const collection = client.db('SkyWise').collection('users');

    // Find the user with the provided username
    const user = await collection.findOne({ username });

    if (!user) {
      // User not found
      return res.status(404).json({ success: false, message: 'User not found' });
    }

    // Send the favorite location as a response
    res.status(200).json({ success: true, favoriteLocation: user.location });
  } catch (error) {
    console.log('Error fetching favorite location:', error);

    res.status(500).json({ success: false, message: 'Server error' });
  } finally {
    // Close the MongoDB connection if the client is defined
    if (client) {
      client.close();
      console.log('Disconnected from MongoDB');
    }
  }
});

// Redirect to app.html if logged in
app.get('/app.html', (req, res, next) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.redirect('/');
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.redirect('/');
    }

    next();
  });
});

// Start the server
const port = process.env.SERVER_PORT; // Change this to the desired port number
app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
  console.log(`http://localhost:${port}`);
});

_______________________________

require('dotenv').config();
const express = require('express');
const { MongoClient } = require('mongodb');
const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const session = require('express-session');
const app = express();
const path = require('path');

// Generate a secret key for JWT signing
const secretKey = crypto.randomBytes(32).toString('hex');
console.log(secretKey);

const muser = process.env.MONGODB_USERNAME;
const mpass = process.env.MONGODB_PASSWORD;
const db = process.env.MONGODB_DATABASE;

// Serve static files from the "public" directory
app.use(express.static(path.join(__dirname, 'public')));

// Middleware to parse JSON request body
app.use(express.json());

// Session middleware
app.use(
  session({
    secret: 'your-secret-key',
    resave: false,
    saveUninitialized: false,
    cookie: { maxAge: 3 * 60 * 60 * 1000 }, // 3 hours
  })
);

// Define a route to serve the index.html file
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'index.html'));
});

app.get('/login.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'login.html'));
});

app.get('/register.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'register.html'));
});

app.get('/app.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'app.html'));
});

// MongoDB connection string
const uri = `mongodb+srv://${muser}:${mpass}@alphadbv1.9q93m.mongodb.net/${db}?retryWrites=true&w=majority`;

// Route for handling the registration form submission
app.post('/register', async (req, res) => {
  // ...

  // Redirect to the login.html page
  res.redirect('/login.html');
});

// Route for handling the login request
app.post('/login', async (req, res) => {
  // ...

  // Set the user's session data
  req.session.user = { username: user.username };

  // Login successful, send the token as a response
  res.status(200).json({ success: true, message: 'Login successful', token });
});

// Protected route
app.get('/protected', (req, res) => {
  // ...

  const { username } = req.session.user;

  console.log('Protected route accessed by:', username);
  // Perform any necessary actions for the protected route
  // ...

  res.json({ success: true, message: 'Protected route accessed successfully.' });
});

// Route for fetching the user's favorite location
app.get('/api/user/favorite-location', verifyToken, async (req, res) => {
  // ...

  const { username } = req.session.user;

  // Send the favorite location as a response
  res.status(200).json({ success: true, favoriteLocation: user.location });
});

// Middleware for verifying JWT token
const verifyToken = (req, res, next) => {
  // ...

  req.decoded = decoded;
  next();
};

// Start the server
const port = 5050; // Change this to the desired port number
app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
  console.log(`http://localhost:${port}`);
});


_________________________________

require('dotenv').config();
const express = require('express');
const { MongoClient } = require('mongodb');
const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const session = require('express-session');
const app = express();
const path = require('path');

// Generate a secret key for JWT signing
const secretKey = crypto.randomBytes(32).toString('hex');
console.log(secretKey);

const muser = process.env.MONGODB_USERNAME;
const mpass = process.env.MONGODB_PASSWORD;
const db = process.env.MONGODB_DATABASE;

// Serve static files from the "public" directory
app.use(express.static(path.join(__dirname, 'public')));

// Middleware to parse JSON request body
app.use(express.json());

// Session middleware
app.use(
  session({
    secret: 'your-secret-key',
    resave: false,
    saveUninitialized: false,
    cookie: { maxAge: 3 * 60 * 60 * 1000 }, // 3 hours
  })
);

// Define a route to serve the index.html file
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'index.html'));
});

app.get('/login.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'login.html'));
});

app.get('/register.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'register.html'));
});

app.get('/app.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'app.html'));
});

// MongoDB connection string
const uri = `mongodb+srv://${muser}:${mpass}@alphadbv1.9q93m.mongodb.net/${db}?retryWrites=true&w=majority`;

// Route for handling the registration form submission
app.post('/register', async (req, res) => {
  const { username, email, location, password } = req.body;

  // Validate the registration details here (same validation logic as in auth.js)
  // ...

  let client; // Declare the client variable outside the try block

  try {
    client = new MongoClient(uri);

    await client.connect();
    console.log('Connected to MongoDB');

    const collection = client.db('SkyWise').collection('users');

    // Check if the username or email already exists in the collection
    const existingUser = await collection.findOne({ $or: [{ username }, { email }] });
    if (existingUser) {
      console.log('User already exists:', existingUser);

      return res.status(409).json({ success: false, message: 'User already exists' });
    }

    // Hash the password before storing it
    const hashedPassword = crypto.createHash('sha256').update(password).digest('hex');

    // Insert the registration details into the collection
    await collection.insertOne({ username, email, location, password: hashedPassword });

    console.log('Registration details stored in MongoDB');

    // Redirect to the login.html page
    res.redirect('/login.html');
  } catch (error) {
    console.log('Error storing registration details:', error);

    res.status(500).json({ success: false, message: 'Registration failed' });
  } finally {
    // Close the MongoDB connection if the client is defined
    if (client) {
      client.close();
      console.log('Disconnected from MongoDB');
    }
  }
});

// Route for handling the login request
app.post('/login', async (req, res) => {
  const { username, password } = req.body;

  let client;

  try {
    client = new MongoClient(uri);

    await client.connect();
    console.log('Connected to MongoDB');

    const collection = client.db('SkyWise').collection('users');

    // Find the user with the provided username
    const user = await collection.findOne({ username });

    if (!user) {
      // User not found
      return res.status(401).json({ success: false, message: 'Invalid Username' });
    }

    // Hash the provided password and compare it with the stored password
    const hashedPassword = crypto.createHash('sha256').update(password).digest('hex');

    if (hashedPassword !== user.password) {
      // Passwords don't match
      return res.status(401).json({ success: false, message: 'Invalid Password' });
    }

    // Store the username in the session data
    req.session.user = { username: user.username };

    // Redirect to the app.html page
    res.redirect('/app.html');
  } catch (error) {
    console.log('Error during login:', error);

    res.status(500).json({ success: false, message: 'Login failed' });
  } finally {
    // Close the MongoDB connection if the client is defined
    if (client) {
      client.close();
      console.log('Disconnected from MongoDB');
    }
  }
});

// Protected route
app.get('/protected', async (req, res) => {
  const { username } = req.session.user;

  if (!username) {
    return res.status(401).json({ success: false, message: 'Authorization token not provided' });
  }

  console.log('Protected route accessed by:', username);
  // Perform any necessary actions for the protected route
  // ...

  res.json({ success: true, message: 'Protected route accessed successfully.' });
});

// Route for fetching the user's favorite location
app.get('/api/user/favorite-location', async (req, res) => {
  const { username } = req.session.user;

  let client;

  try {
    client = new MongoClient(uri);

    await client.connect();
    console.log('Connected to MongoDB');

    const collection = client.db('SkyWise').collection('users');

    // Find the user with the provided username
    const user = await collection.findOne({ username });

    if (!user) {
      // User not found
      return res.status(404).json({ success: false, message: 'User not found' });
    }

    // Send the favorite location as a response
    res.status(200).json({ success: true, favoriteLocation: user.location });
  } catch (error) {
    console.log('Error fetching favorite location:', error);

    res.status(500).json({ success: false, message: 'Server error' });
  } finally {
    // Close the MongoDB connection if the client is defined
    if (client) {
      client.close();
      console.log('Disconnected from MongoDB');
    }
  }
});

// Start the server
const port = 5050; // Change this to the desired port number
app.listen(port, async () => {
  console.log(`Server is running on port ${port}`);
  console.log(`http://localhost:${port}`);
});

-----------------------------------------

require('dotenv').config();
const express = require('express');
const { MongoClient } = require('mongodb');
const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const app = express();
const path = require('path');
const url = require('url');

// Generate a secret key for JWT signing
const secretKey = crypto.randomBytes(32).toString('hex');
console.log(secretKey);

const muser = process.env.MONGODB_USERNAME;
const mpass = process.env.MONGODB_PASSWORD;
const db = process.env.MONGODB_DATABASE;

// Serve static files from the "public" directory
app.use(express.static(path.join(__dirname, 'public')));

// Middleware to parse JSON request body
app.use(express.json());

// Define a route to serve the index.html file
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'index.html'));
});

app.get('/login.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'login.html'));
});

app.get('/register.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'register.html'));
});

app.get('/app.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'app.html'));
});

// MongoDB connection string
const uri = `mongodb+srv://${muser}:${mpass}@alphadbv1.9q93m.mongodb.net/${db}?retryWrites=true&w=majority`;

// Route for handling the registration form submission
app.post('/register', async (req, res) => {
  // ... existing code for registration ...

  res.redirect('/login.html');
});

// Route for handling the login request
app.post('/login', async (req, res) => {
  // ... existing code for login ...

  res.status(200).json({ success: true, message: 'Login successful', token });
});

// Protected route
app.get('/protected', (req, res) => {
  // ... existing code for protected route ...
});

// Middleware for verifying JWT token
const verifyToken = (req, res, next) => {
  const token = req.headers.authorization;

  if (!token) {
    return res.status(401).json({ success: false, message: 'Authorization token not provided' });
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.status(403).json({ success: false, message: 'Invalid token' });
    }

    req.decoded = decoded;
    next();
  });
};

// Middleware to restrict access to the /app.html page
app.use('/app.html', (req, res, next) => {
  const token = req.headers.authorization;

  if (!token) {
    const redirectUrl = url.format({
      protocol: req.protocol,
      host: req.get('host'),
      pathname: '/'
    });
    return res.redirect(redirectUrl);
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      const redirectUrl = url.format({
        protocol: req.protocol,
        host: req.get('host'),
        pathname: '/'
      });
      return res.redirect(redirectUrl);
    }

    next();
  });
});

// Route for fetching the user's favorite location
app.get('/api/user/favorite-location', verifyToken, async (req, res) => {
  // ... existing code for fetching favorite location ...
});

// Start the server
const port = 5050; // Change this to the desired port number
app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
  console.log(`http://localhost:${port}`);
});

_____________________________________

// Route for handling the login request
app.post('/login', async (req, res) => {
  const { username, password } = req.body;

  let client;

  try {
    client = new MongoClient(uri);

    await client.connect();
    console.log('Connected to MongoDB');

    const collection = client.db('SkyWise').collection('users');

    // Find the user with the provided username
    const user = await collection.findOne({ username });

    if (!user) {
      // User not found
      return res.status(401).json({ success: false, message: 'Invalid Username' });
    }

    // Hash the provided password and compare it with the stored password
    const hashedPassword = crypto.createHash('sha256').update(password).digest('hex');

    if (hashedPassword !== user.password) {
      // Passwords don't match
      return res.status(401).json({ success: false, message: 'Invalid Password' });
    }

    // Generate a JWT token
    const token = jwt.sign({ username: user.username }, secretKey, { expiresIn: '1h' });

    // Login successful, send the token as a response and store it in local storage
    res.status(200).json({ success: true, message: 'Login successful', token });

    // Store the token securely in local storage
    // Note: Make sure to handle security considerations such as XSS attacks when storing sensitive information in local storage
    if (typeof Storage !== 'undefined') {
      localStorage.setItem('token', token);
    } else {
      console.log('Local storage is not supported.');
    }
  } catch (error) {
    console.log('Error during login:', error);

    res.status(500).json({ success: false, message: 'Login failed' });
  } finally {
    // Close the MongoDB connection if the client is defined
    if (client) {
      client.close();
      console.log('Disconnected from MongoDB');
    }
  }
});

_____________________________________

// Middleware to restrict access to the /app.html page
const restrictAccess = (req, res, next) => {
  const token = req.cookies.token;

  if (!token) {
    return res.redirect('/');
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.redirect('/');
    }

    req.decoded = decoded;
    next();
  });
};

// Serve the app.html file only if the user is authenticated
app.get('/app.html', restrictAccess, (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'app.html'));
});

_____________________________________

// Serve the app.html file only if the user is authenticated
app.get('/app.html', restrictAccess, (req, res) => {
  res.sendFile(path.join(__dirname, 'views', 'app.html'));
});

// Middleware to restrict access to the /app.html page
const restrictAccess = (req, res, next) => {
  const token = req.cookies.token;

  if (!token) {
    return res.redirect('/');
  }

  jwt.verify(token, secretKey, (err, decoded) => {
    if (err) {
      return res.redirect('/');
    }

    req.decoded = decoded;
    next();
  });
};


